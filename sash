#!/usr/bin/env bash

SASH_VERSION="0.1.0"

# Library section

rand_str() { xxd -l8 -ps /dev/urandom ; }

now_utc()        { date -u +"%Y%m%dT%H%M%SZ"     ; }
now_utc_pretty() { date -u +"%Y-%m-%dT%H:%M:%SZ" ; }

println_err() { printf "%s\n" "$*" 1>&2 ; }
println()     { printf "%s\n" "$*"      ; }

with_color() {
  local color_code="$1" ; shift
  local pattern="${1:-.*}"
  local line="$(cat -)"
  local COLORS="${SASH_COLORS:-true}"

  if [ "$COLORS" = "true" ] ; then
    println "$line" | GREP_COLOR="01;${color_code}" \
                      GREP_COLORS="mt=01;${color_code}" \
                      grep --color=always "$pattern" || println "$line"
  else
    println "$line"
  fi
}

blue()   { with_color 36 "$@" 1>&2 ; }
blue2()  { with_color 34 "$@" 1>&2 ; }
green()  { with_color 32 "$@" 1>&2 ; }
grey()   { with_color 90 "$@" 1>&2 ; }
purple() { with_color 35 "$@" 1>&2 ; }
red()    { with_color 31 "$@" 1>&2 ; }
yellow() { with_color 33 "$@" 1>&2 ; }

log() {
  local lvl="$1" ; shift
  println_err "$(now_utc_pretty) [${lvl}] ~ ${*}"
}

log_color() {
  local lvl="$1"   ; shift
  local color="$1" ; shift

  println "$(now_utc_pretty) [${lvl}] ~ $*" | "$color" 1>&2 ;
}

info_blue() { log_color INFO  blue   "$@"         ; }
info()      { log_color INFO  green  "$@"         ; }
error()     { log_color ERROR red    "$@"         ; }
warn()      { log_color WARN  yellow "$@"         ; }
fail()      { log_color FAIL  red    "$@" ; false ; }
debug() {
  _DEBUG="${DEBUG:-0}"

  if [[ "$_DEBUG" -gt "0" ]] ; then
    log_color DEBUG grey "$@"
  fi
}

trim() { local a=("$1") ; println "${a[*]}" ; }
cnt_char() { println "$1" | awk -F ":" '{print NF-1}' ; }

file_exists() { test -f "$1" || fail "file '${1}' not found"                                  ; }
dir_exists()  { test -d "$1" || fail "directory '${1}' not found"                             ; }
cmds_exist()  { type "$@" >/dev/null 2>&1 || fail "some commands in [${@}] are not available" ; }
cmd_exists()  { type "$1" >/dev/null 2>&1 || fail "command '${1}' not available"              ; }

# Check if any argument contains a variable (ABC=123)
args_contain_var() {
  local var="$1" ; shift

  local arg
  for arg in "$@" ; do
    if [[ "$arg" == "${var}="* ]] ; then
      return 0
    fi
  done
  return 1
}

# Print each function argument as a new line
print_args() {
  local arg
  for arg in "$@"; do
    println "$arg"
  done
}

# Export content of given env file in current shell
export_env_file() {
  while read -r _sash_export_var <&3 ; do
    export "$(trim "${_sash_export_var}")"
  done 3< <(cat "$1" | grep "=")
}

# Read config file, comments and empty lines are ignored
read_config_file() {
  (
    while IFS= read -r line <&3 ; do
      trim "$line"
    done 3< "$1"
   ) | grep -v "^#.*\|^$"
}

# Write stdin data atomically to file, using a temporary file
atomic_write() {
  local file="$(realpath "${1}")" ; shift
  local dir="$(dirname "${file}")"
  local tmp_file="${dir}/.$(rand_str).tmp"

  cat > "$tmp_file"
  mv "$tmp_file" "$file"
}

# Interpolate all environment variables present in input
# Can be optimized...
env_subst() {
  python -c '''
import os, sys
data = sys.stdin.read(65536)
for v in os.environ:
  data = data.replace("$%s" % v, os.environ[v])
  data = data.replace("${%s}" % v, os.environ[v])
sys.stdout.write(data) ; sys.stdout.flush()
'''
}

# Main section

# Only run this routine if the script is not sourced
(return 0 2>/dev/null) || (
  set -Cue -o pipefail

  # Dirs
  THIS_DIR="$(cd "$(dirname "$(readlink "${0}" || printf "${0}")")" ; pwd)" # Absolute path to module
  THIS_SCRIPT="${THIS_DIR}/sash"
  TMP_DIR="${TMP_DIR:-/tmp}"

  required_commands=(date ssh tar gzip python)

  # Env
  DEBUG="${SASH_DEBUG:-0}"
  WORK_DIR="${SASH_DIR:-"${PWD}"}"
  SSH_CONTROL_PERSIST="${SASH_SSH_CONTROL_PERSIST:-2s}"

  if [ "$DEBUG" == "true" ] ; then DEBUG="1" ; fi
  if [ "$DEBUG" == "2"    ] ; then set -x    ; fi

  # Check if all required commands are available
  check_dependencies() {
    # TODO check bash version > 4.3
    if ! cmds_exist "$@" ; then
      local cmd
      for cmd in "$@" ; do
        cmd_exists "$cmd"
      done
    fi
  }

  # Read top vars from runbook
  vars_from_runbook() {
    read_config_file "$1" | env_subst | grep -v ".*[[:space:]].*" | grep "="
  }

  # Read all target lines from runbook
  targets_from_runbook() {
    read_config_file "$1" | env_subst | grep ".*[[:space:]].*"
  }

  # Management of the arrays holding the different environment variables
  declare -n cli_vars_ref="cli_vars"   ; cli_vars=()
  declare -n file_vars_ref="file_vars" ; file_vars=()
  declare -n line_vars_ref="line_vars" ; line_vars=()
  declare -n all_vars_ref="all_vars"   ; all_vars=()

  vars() {
    # Grab the array from its name
    local vars_name="$1" ; shift
    local -n v="$vars_name"

    push() {
      local var_line="$1" ; shift
      local name="${var_line%%=*}"

      if ! args_contain_var "$name" "${v[@]}" ; then
        v+=("$var_line")
      fi
    }

    # Read variables from stdin and append them to $vars, existing in the outer scope
    push_from_input() {
      local var_line
      while IFS= read -r var_line <&3 ; do
        push "$(trim "${var_line}")"
      done 3< <(cat -)
    }

    # Read variables from the arguments and append them to $vars, existing in the outer scope
    push_from_args() {
      local var_line
      for var_line in "$@" ; do
        if [[ "$var_line" == *"="* ]]; then # Only consider args with = ([[ needed for globbing)
          push "$var_line"
        fi
      done
    }

    merge() {
      for var in "$@" ; do
        push "$var"
      done
    }

    clear() {
      v=()
    }

    merge_all() {
      clear
      merge "${cli_vars[@]}" "${line_vars[@]}" "${file_vars[@]}"
    }

    "$@"
  }

  # Wrapper script that will run the deploy executable
  sash_script() {
    cat << EOS
#!/usr/bin/env bash

set -Cue -o pipefail

THIS_DIR="\$(cd "\$(dirname "\${0}")" ; pwd)"

(
  cd "\$THIS_DIR"

  . sash

  export_env_file deploy.env

  info ">> running 'deploy' for target '\${SASH_TARGET}' ..."
  ./deploy
  info "<< ran 'deploy' for target '\${SASH_TARGET}' successfully"
)
EOS
  }

  print_help() {
    info "help"
  }

  print_version() {
    println "$SASH_VERSION"
  }

  build_target() {
    local target_dir="$1" ; shift
    local build_dir="$1"  ; shift

    # Flavor in dir name
    if [ "$(cnt_char "$target_dir")" == "1" ] ; then
      local flavor="$(echo "$target_dir" | cut -d":" -f1)"
      local target_dir="$(echo "$target_dir" | cut -d":" -f2)"

      vars line_vars push SASH_FLAVOR="$flavor"
    fi

    local target_dir="$(realpath "${target_dir}")"
    local target="$(basename "${target_dir}")"

    dir_exists "$target_dir"

    # Prepare all environment variables
    vars all_vars merge_all

    # Select content of the target dir

    # Include this script, the deploy routine and environment file
    (
      cd "$build_dir"

      cp "${THIS_SCRIPT}" .
      sash_script > sash.script
      chmod +x "${THIS_SCRIPT}" sash.script

      # Gather all variables in a single env file
      print_args \
        "SASH_TARGET=${target}" \
        "${all_vars[@]}" | sort > deploy.env
    )

    # Make sure all variables are available in this scope
    export_env_file "${build_dir}/deploy.env"

    # Include content of target dir
    (
      cd "$target_dir"

      find . -mindepth 1 -maxdepth 1 \
        -not -name "flavors" \
        -exec cp -r '{}' "$build_dir" ';'
    )

    # Select the correct flavor separately
    local flavor="${SASH_FLAVOR:-}"
    local flavor_dir="${target_dir}/flavors/${flavor}"

    test -z "$flavor" || (
      dir_exists "$flavor_dir"

      cd "$flavor_dir"

      mkdir -p "${build_dir}/flavor"

      find . -mindepth 1 -maxdepth 1 \
        -exec cp -r '{}' "${build_dir}/flavor" ';'
    )

    # Handle include files
    (
      locate_include_files() {
        find . \
          -maxdepth 1 -mindepth 1 \
          -type f \
          \( -name "*.inc" -o -name "*.incl" -o -name "*.include" -o -name "*.includes" \) \
          -print0
      }

      cd "$target_dir"

      while IFS= read -r -d '' file <&3 ; do
        src_dir="$(cd "$(dirname "${target_dir}/${file}")" ; pwd)"
        dst_dir="$build_dir"

        include_item() {
          local src="$1" ; shift
          local dst="$1" ; shift
          local src_path="$(realpath "${src_dir}/${src}")"
          local dst_path="${dst_dir}/${dst}"
          local src_name="$(basename "${src_path}")"

          info "including item '${src_name}'"
          cp -r "$src_path" "$dst_path"
        }

        while IFS= read -r line <&4 ; do
          read -a args <<< "$line"
          include_item "${args[@]}"
        done 4< <(read_config_file "$file" | env_subst)
      done 3< <(locate_include_files)
    )

    # Handle template files
    (
      locate_template_files() {
        find . \
          -maxdepth 1 -mindepth 1 \
          -type f \
          \( -name "*.tpl" -o -name "*.templ" -o -name "*.template" \) \
          -print0
      }

      cd "$build_dir"

      while IFS= read -r -d '' file <&3 ; do
        dst_path="${file%.tpl}"
        cat "$file" | env_subst | atomic_write "$dst_path"
        rm "$file"
      done 3< <(locate_template_files)
    )
  }

  deploy() {
    (
      host="$1"      ; shift
      build_dir="$1" ; shift
      remote_dir="sash"
      control_path="${TMP_DIR}/.$(rand_str).tmp"

      cleanup_connection() {
        ssh -O exit -oControlPath="$control_path" "$host" >/dev/null 2>&1
        rm -f "$control_path"
      }

      trap cleanup_connection 0

      (
        cd "$build_dir"

        # Copy target
        tar -f - -cz . | ssh \
          -T \
          -oControlMaster=yes \
          -oControlPath="$control_path" \
          -oControlPersist="$SSH_CONTROL_PERSIST" \
          "$host" \
          "mkdir -p \"${remote_dir}\" && tar -f - -C \"${remote_dir}\" -xz"

        # Re-use the previous ssh master session
        ssh \
          -tt \
          -oControlPath="$control_path" \
          "$host" \
          "\"${remote_dir}/sash.script\""
      )
    )
  }

  deploy_target() {
    local host="$1"       ; shift
    local target_dir="$1" ; shift
    local build_dir="${TMP_DIR}/.$(rand_str).tmp"

    trap "rm -rf '${build_dir}'" 0

    debug "deploying target '${target_dir}' on '${host}'"

    mkdir -p "$build_dir"

    build_target "$target_dir" "$build_dir"
    deploy       "$host"       "$build_dir"
  }

  deploy_runbook() {
    local runbook_path="$(realpath "${1}")" ; shift
    local runbook_dir="$(dirname "${runbook_path}")"

    file_exists "$runbook_path"

    debug "deploying runbook '${runbook_path}'"

    vars cli_vars  push_from_args "$@"
    vars file_vars push_from_input <<<"$(vars_from_runbook "$runbook_path")"

    while read line <&3 ; do
      # Transform all elements of the line as positional arguments
      read -a args <<< "$line"
      set -- ; set -- "${args[@]}" "$@"

      host="$1"                    ; shift
      target="${runbook_dir}/${1}" ; shift

      vars line_vars clear
      vars line_vars push_from_args "$@"

      deploy_target "$host" "$target"
    done 3< <(targets_from_runbook "$runbook_path")
  }

  run_deploy() {
    if [ -f "$1" ] ; then
      deploy_runbook "$@"
    else
      host="$1"   ; shift
      target="$1" ; shift

      vars cli_vars push_from_args "$@"

      deploy_target "$host" "$target"
    fi
  }

  check_dependencies "${required_commands[@]}"

  test "$#" -eq 0 && { print_help ; exit ; }

  cmd="$1"
  case "$cmd" in
    "-h" | "--help"    | "help"   ) shift ; print_help    "$@" ; exit ;;
    "-v" | "--version" | "version") shift ; print_version "$@" ; exit ;;
    "-d" | "--deploy"  | "deploy" ) shift ; run_deploy    "$@" ; exit ;;
    *                             )         run_deploy    "$@" ; exit ;;
  esac
)
