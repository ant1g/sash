#!/usr/bin/env bash

DOS_VERSION="0.1.0"

# Library section

rand_str() { xxd -l8 -ps /dev/urandom ; }

now_utc_pretty() { date -u +"%Y-%m-%dT%H:%M:%SZ" ; }

println_err() { printf "%s\n" "$*" 1>&2 ; }
println()     { printf "%s\n" "$*"      ; }

log() {
  local lvl="$1" ; shift

  println_err "$(now_utc_pretty) [${lvl}] ~ ${*}"
}

info() { log INFO "$@"         ; }
fail() { log FAIL "$@" ; false ; }

trim() { local a=("$1") ; println "${a[*]}" ; }

file_exists() { test -f "$1" || fail "file '${1}' not found"                                  ; }
dir_exists()  { test -d "$1" || fail "directory '${1}' not found"                             ; }
cmds_exist()  { type "$@" >/dev/null 2>&1 || fail "some commands in [${@}] are not available" ; }
cmd_exists()  { type "$1" >/dev/null 2>&1 || fail "command '${1}' not available"              ; }

# Check if any argument contains a variable (ABC=123)
args_contains_var() {
  local var="$1" ; shift
  local arg
  for arg in "$@" ; do
    if [[ "$arg" == "${var}="* ]] ; then
      return 0
    fi
  done
  return 1
}

# Print all arguments
print_args() {
  local arg
  for arg in "$@"; do
    println "$arg"
  done
}

# Export content of given env file in current shell
export_env_file() {
  while read -r _dos_var5 <&5 ; do
    export "$(trim "${_dos_var5}")"
  done 5< <(cat "$1" | grep "=")
}

# Read config file
read_config_file() {
  (
    while IFS= read -r line <&3 ; do
      trim "$line"
    done 3< "$1"
   ) | grep -v "^#.*\|^$"
}

# Write stdin data atomically to file, using a temporary file
atomic_write() {
  local file="$(realpath "${1}")" ; shift

  local dir="$(dirname "${file}")"
  local tmp_file="${dir}/.$(rand_str).tmp"

  cat > "$tmp_file"
  mv "$tmp_file" "$file"
}

# Interpolate all environment variables present in input
# Can be optimized...
env_subst() {
  python -c '''
import os, sys
data = sys.stdin.read()
for v in os.environ:
  data = data.replace("$%s" % v, os.environ[v])
  data = data.replace("${%s}" % v, os.environ[v])
sys.stdout.write(data) ; sys.stdout.flush()
'''
}

# Main section

# Only run this routine if the script is not sourced
(return 0 2>/dev/null) || (

  set -Cue -o pipefail

  SCRIPT_NAME="$(basename "${0}")"
  THIS_DIR="$(cd "$(dirname "$(readlink "${0}" || printf "${0}")")" ; pwd)" # Absolute path to module
  THIS_SCRIPT="${THIS_DIR}/${SCRIPT_NAME}"
  DEBUG="${DOS_DEBUG:-false}"
  WORK_DIR="${DOS_DIR:-"${PWD}"}"
  TMP_DIR="${TMP_DIR:-/tmp}"

  # Env
  SSH_CONTROL_PERSIST="${SSH_CONTROL_PERSIST:-2s}"
  EXTRA_VARS=()

  required_commands=(date ssh tar gzip python)

  check_dependencies() {
    if ! cmds_exist "$@" ; then
      local cmd
      for cmd in "$@" ; do
        cmd_exists "$cmd"
      done
    fi
  }

  # Add new var to EXTRA_VARS if not already present
  add_extra_var() {
    local var_line="$1" ; shift

    local name="${var_line%%=*}"

    if ! args_contains_var "$name" "${EXTRA_VARS[@]}" ; then # Check if var name is not already processed
        EXTRA_VARS+=("$var_line")
    fi
  }

  # Read variables from a file and append them to EXTRA_VARS, existing in the outer scope
  read_file_extra_vars() {
    local var_line
    while IFS= read -r var_line <&6 ; do
      add_extra_var "$(trim "${var_line}")"
    done 6< <(read_config_file "$1" | grep "=")
  }

  # Read variables from the command line and add them to EXTRA_VARS, existing in the outer scope
  read_cli_extra_vars() {
    local var_line
    for var_line in "$@" ; do
      if [[ "$var_line" == *"="* ]]; then # Only consider args with = ([[ needed for globbing)
        add_extra_var "$var_line"
      fi
    done
  }

  # Wrapper script that will run the deploy executable
  dos_script() {
    cat << EOS
#!/usr/bin/env bash

set -Cue -o pipefail

THIS_DIR="\$(cd "\$(dirname "\${0}")" ; pwd)"

(
  cd "\$THIS_DIR"

  . dos

  export_env_file deploy.env

  info ">> running 'deploy' for target '\${DOS_TARGET}' ..."
  ./deploy
  info "<< ran 'deploy' for target '\${DOS_TARGET}' successfully"
)
EOS
  }

  print_help() {
    info "help"
  }

  print_version() {
    println "$DOS_VERSION"
  }

  build_target() {
    local build_dir="$1"  ; shift
    local target_dir="$1" ; shift

    local target="$(basename "${target_dir}")"
    local flavor="${DOS_FLAVOR:-}"
    local flavor_dir="${target_dir}/flavors/${flavor}"

    # Ensure dirs exist
    dir_exists "$target_dir"
    test -z "$flavor" || { dir_exists "$flavor_dir" ; }

    # Select content of the target dir

    # Include this script, the deploy routine and environment file
    (
      cd "$build_dir"

      cp "${THIS_SCRIPT}" .
      dos_script > dos.script
      chmod +x "${THIS_SCRIPT}" dos.script

      # Gather all variables in an env file
      print_args \
        "DOS_TARGET=${target}" \
        "DOS_FLAVOR=${flavor}" \
        "${EXTRA_VARS[@]}" > deploy.env

      cat deploy.env
    )

    # Make sure all variables are available in this scope
    export_env_file "${build_dir}/deploy.env"

    # Include content of target dir
    (
      cd "$target_dir"

      find . -mindepth 1 -maxdepth 1 \
        -not -name "flavors" \
        -exec cp -r '{}' "$build_dir" ';'
    )

    # Select the correct flavor separately
    test -z "$flavor" || (
      cd "$flavor_dir"

      mkdir -p "${build_dir}/flavor"

      find . -mindepth 1 -maxdepth 1 \
        -exec cp -r '{}' "${build_dir}/flavor" ';'
    )

    # Handle include files
    (
      cd "$target_dir"

      while IFS= read -r -d '' file <&3 ; do
        src_dir="$(cd "$(dirname "${target_dir}/${file}")" ; pwd)"
        dst_dir="$build_dir"

        include_item() {
          local src="$1" ; shift
          local dst="$1" ; shift

          local src_path="$(realpath "${src_dir}/${src}")"
          local dst_path="${dst_dir}/${dst}"
          local src_name="$(basename "${src_path}")"

          info "including item '${src_name}'"
          cp -r "$src_path" "$dst_path"
        }

        while IFS= read -r line <&4 ; do
          read -a args <<< "$line"
          include_item "${args[@]}"
        done 4< <(read_config_file "$file" | env_subst)
      done 3< <(find . -maxdepth 1 -mindepth 1 -type f -name "*.incl" -print0)
    )

    # Handle template files
    (
      cd "$build_dir"

      while IFS= read -r -d '' file <&3 ; do
        dst_path="${file%.tpl}"
        cat "$file" | env_subst | atomic_write "$dst_path"
        rm "$file"
      done 3< <(find . -type f -name "*.tpl" -print0)
    )

    # TODO remove
    find "$build_dir"
  }

  deploy() {
    (
      build_dir="$1" ; shift
      host="$1"      ; shift

      remote_dir="dos"
      control_path="${TMP_DIR}/.$(rand_str).tmp"

      cleanup_connection() {
        ssh -O exit -oControlPath="$control_path" "$host" >/dev/null 2>&1
        rm -f "$control_path"
      }

      trap cleanup_connection 0

      (
        cd "$build_dir"

        # Copy target
        tar -f - -cz . | ssh \
          -T \
          -oControlMaster=yes \
          -oControlPath="$control_path" \
          -oControlPersist="$SSH_CONTROL_PERSIST" \
          "$host" \
          "mkdir -p \"${remote_dir}\" && tar -f - -C \"${remote_dir}\" -xz"

        # Re-use the previous ssh master session
        ssh \
          -tt \
          -oControlPath="$control_path" \
          "$host" \
          "\"${remote_dir}/dos.script\""
      )
    )
  }

  deploy_target() {
    local host="$1"   ; shift
    local target="$1" ; shift

    local target_dir="$(cd "${target}" ; pwd)"
    local build_dir="${TMP_DIR}/.$(rand_str).tmp"

    trap "rm -rf '${build_dir}'" 0

    mkdir -p "$build_dir"

    build_target "$build_dir" "$target_dir"
    deploy       "$build_dir" "$host"
  }

  deploy_runbook() {
    local runbook_path="$1" ; shift

    file_exists "$runbook_path"
  }

  run_deploy() {
    if [ -f "$1" ] ; then
      deploy_runbook "$@"
    else
      host="$1"   ; shift
      target="$1" ; shift

      read_cli_extra_vars "$@"

      deploy_target "$host" "$target"
    fi
  }

  check_dependencies "${required_commands[@]}"

  test "$#" -eq 0 && { print_help ; exit ; }

  cmd="$1"
  case "$cmd" in
    "-h" | "--help"    | "help"   ) shift ; print_help    "$@" ; exit ;;
    "-v" | "--version" | "version") shift ; print_version "$@" ; exit ;;
    "-d" | "--deploy"  | "deploy" ) shift ; run_deploy    "$@" ; exit ;;
    *                             )         run_deploy    "$@" ; exit ;;
  esac
)
