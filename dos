#!/usr/bin/env bash

DOS_VERSION="0.1.0"

# Library section

rand_str() { xxd -l8 -ps /dev/urandom ; }

now_utc_pretty() { date -u +"%Y-%m-%dT%H:%M:%SZ" ; }

println_err() { printf "%s\n" "$*" 1>&2 ; }
println()     { printf "%s\n" "$*"      ; }

log() {
  local lvl="$1" ; shift

  println_err "$(now_utc_pretty) [${lvl}] ~ ${*}"
}

info() { log INFO "$@"         ; }
fail() { log FAIL "$@" ; false ; }

trim() { local a=("$1") ; println "${a[*]}" ; }

file_exists() { test -f "$1" || fail "file '${1}' not found"                                  ; }
dir_exists()  { test -d "$1" || fail "directory '${1}' not found"                             ; }
cmds_exist()  { type "$@" >/dev/null 2>&1 || fail "some commands in [${@}] are not available" ; }
cmd_exists()  { type "$1" >/dev/null 2>&1 || fail "command '${1}' not available"              ; }

# Read config file
read_config_file() {
  (
    while IFS= read -r line <&3 ; do
      trim "$line"
    done 3< "$1"
   ) | grep -v "^#.*\|^$"
}

# Write stdin data atomically to file, using a temporary file
atomic_write() {
  local file="$(realpath "${1}")" ; shift
  local dir="$(dirname "$file")"
  local tmp_file="${dir}/.$(rand_str).tmp"

  cat > "$tmp_file"
  mv "$tmp_file" "$file"
}

# Interpolate all environment variables present in input
# Can be optimized...
env_subst() {
  python -c '''
import os, sys
data = sys.stdin.read()
for v in os.environ:
  data = data.replace("$%s" % v, os.environ[v])
  data = data.replace("${%s}" % v, os.environ[v])
sys.stdout.write(data) ; sys.stdout.flush()
'''
}

# Main section

# Only run this routine if the script is not sourced
(return 0 2>/dev/null) || (

  set -Cue -o pipefail

  SCRIPT_NAME="$(basename "${0}")"
  THIS_DIR="$(cd "$(dirname "$(readlink "${0}" || echo "${0}")")" ; pwd)" # Absolute path to module
  THIS_SCRIPT="${THIS_DIR}/${SCRIPT_NAME}"
  DEBUG="${DOS_DEBUG:-false}"
  WORK_DIR="${DOS_DIR:-"${PWD}"}"
  TMP_DIR="${TMP_DIR:-/tmp}"

  # Env
  SSH_CONTROL_PERSIST="${SSH_CONTROL_PERSIST:-2s}"

  required_commands=(date ssh tar gzip python)

  check_dependencies() {
    if ! cmds_exist "$@" ; then
      local cmd
      for cmd in "$@" ; do
        cmd_exists "$cmd"
      done
    fi
  }

  print_help() {
    info "help"
  }

  print_version() {
    println "$DOS_VERSION"
  }

  build_target() {
    local build_dir="$1"  ; shift
    local target_dir="$1" ; shift
    local flavor="${DOS_FLAVOR:-}"
    local flavor_dir="${target_dir}/flavors/${flavor}"

    # Ensure dirs exist
    dir_exists "$target_dir"
    test -z "$flavor" || { dir_exists "$flavor_dir" ; }

    # Select content of the target dir

    # Include this script
    cp "${THIS_SCRIPT}" "$build_dir"
    chmod +x "${build_dir}/${SCRIPT_NAME}"

    # Include content of target dir
    (
      cd "$target_dir"

      find . -mindepth 1 -maxdepth 1 \
        -not -name "flavors" \
        -exec cp -r '{}' "$build_dir" ';'
    )

    # Select the correct flavor separately
    test -z "$flavor" || (
      cd "$flavor_dir"

      mkdir -p "${build_dir}/flavor"

      find . -mindepth 1 -maxdepth 1 \
        -exec cp -r '{}' "${build_dir}/flavor" ';'
    )

    # Handle include files
    (
      cd "$target_dir"

      while IFS= read -r -d '' file <&3 ; do
        src_dir="$(cd "$(dirname "${target_dir}/${file}")" ; pwd)"
        dst_dir="$build_dir"

        include_item() {
          local src="$1" ; shift
          local dst="$1" ; shift
          local src_path="$(realpath "${src_dir}/${src}")"
          local dst_path="${dst_dir}/${dst}"
          local src_name="$(basename "${src_path}")"

          info "including item '${src_name}'"
          cp -r "$src_path" "$dst_path"
        }

        while IFS= read -r line <&4 ; do
          read -a args <<< "$line"
          include_item "${args[@]}"
        done 4< <(read_config_file "$file" | env_subst)
      done 3< <(find . -maxdepth 1 -mindepth 1 -type f -name "*.incl" -print0)
    )

    # Handle template files
    (
      cd "$build_dir"

      while IFS= read -r -d '' file <&3 ; do
        dst_path="${file%.tpl}"
        cat "$file" | env_subst | atomic_write "$dst_path"
        rm "$file"
      done 3< <(find . -type f -name "*.tpl" -print0)
    )

    # TODO remove
    find "$build_dir"
  }

  deploy() {
    (
      build_dir="$1" ; shift
      host="$1"      ; shift

      remote_dir="dos"
      control_path="${TMP_DIR}/.$(rand_str).tmp"
      cmd_1="mkdir -p \"${remote_dir}\" && tar -f - -C \"${remote_dir}\" -xz"
      cmd_2="ls -larth \"${remote_dir}\""

      cleanup_connection() {
        ssh -O exit -oControlPath="$control_path" "$host" >/dev/null 2>&1
        rm -f "$control_path"
      }

      trap cleanup_connection 0

      (
        cd "$build_dir"

        # Copy target
        tar -f - -cz . | ssh \
          -T \
          -oControlMaster=yes \
          -oControlPath="$control_path" \
          -oControlPersist="$SSH_CONTROL_PERSIST" \
          "$host" \
          "$cmd_1"

        # Re-use the previous ssh master session
        ssh \
          -tt \
          -oControlPath="$control_path" \
          "$host" \
          "$cmd_2"
      )
    )
  }

  run_deploy() {
    local host="$1"   ; shift
    local target="$1" ; shift

    local target_dir="$(cd "${target}" ; pwd)"
    local build_dir="${TMP_DIR}/.$(rand_str).tmp"

    trap "rm -rf '${build_dir}'" 0

    mkdir -p "$build_dir"

    build_target "$build_dir" "$target_dir"
    deploy       "$build_dir" "$host"
  }

  check_dependencies "${required_commands[@]}"

  test "$#" -eq 0 && { print_help ; exit ; }

  cmd="$1"
  case "$cmd" in
    "-h" | "--help"    | "help"   ) shift ; print_help    "$@" ; exit ;;
    "-v" | "--version" | "version") shift ; print_version "$@" ; exit ;;
    "-d" | "--deploy"  | "deploy" ) shift ; run_deploy    "$@" ; exit ;;
    *                             )         run_deploy    "$@" ; exit ;;
  esac
)
